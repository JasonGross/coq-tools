# autogenerated by cat /path/to/coq/doc/tools/docgram/fullGrammar | ./generate-full-grammar.py > coq_full_grammar.py
__all__ = ["COQ_GRAMMAR_TOKENS"]

COQ_GRAMMAR_TOKENS = [
    "Abort",
    "About",
    "Add",
    "Admit",
    "Admitted",
    "All",
    "Arguments",
    "As",
    "Assumptions",
    "Axiom",
    "Axioms",
    "Back",
    "BackTo",
    "BinOp",
    "BinOpSpec",
    "BinRel",
    "Bind",
    "Blacklist",
    "Boolean",
    "Canonical",
    "Case",
    "Cd",
    "Check",
    "Class",
    "Classes",
    "Close",
    "CoFixpoint",
    "CoInductive",
    "Coercion",
    "Coercions",
    "Collection",
    "Combined",
    "Comments",
    "Compute",
    "Conjecture",
    "Conjectures",
    "Constant",
    "Constants",
    "Constraint",
    "Constructors",
    "Context",
    "Corollary",
    "Create",
    "CstOp",
    "Cumulative",
    "Custom",
    "Cut",
    "CutOff",
    "Debug",
    "Declare",
    "Defined",
    "Definition",
    "Delimit",
    "Dependencies",
    "Dependency",
    "Dependent",
    "Derive",
    "Diffs",
    "Drop",
    "Elimination",
    "End",
    "Entry",
    "Equality",
    "Equivalent",
    "Eval",
    "Example",
    "Existentials",
    "Existing",
    "Export",
    "Extern",
    "Extra",
    "Extract",
    "Extraction",
    "Fact",
    "Fail",
    "Field",
    "Fields",
    "File",
    "Firstorder",
    "Fixpoint",
    "Flags",
    "Focus",
    "Format",
    "From",
    "Funclass",
    "Function",
    "Functional",
    "GC",
    "Generalizable",
    "Generate",
    "Global",
    "Goal",
    "Grammar",
    "Graph",
    "Guarded",
    "Haskell",
    "Heap",
    "Hint",
    "HintDb",
    "Hints",
    "Hypotheses",
    "Hypothesis",
    "Identity",
    "Immediate",
    "Implicit",
    "Implicits",
    "Import",
    "Include",
    "Induction",
    "Inductive",
    "Infix",
    "Info",
    "Initial",
    "InjTyp",
    "Inline",
    "Inlined",
    "Inspect",
    "Instance",
    "Instances",
    "Intro",
    "Intros",
    "Inversion",
    "Inversion_clear",
    "JSON",
    "Keys",
    "Language",
    "Left",
    "Lemma",
    "Let",
    "Lia",
    "Libraries",
    "Library",
    "Load",
    "LoadPath",
    "Local",
    "Locate",
    "Ltac",
    "Ltac2",
    "ML",
    "Match",
    "Method",
    "Minimality",
    "Mode",
    "Module",
    "Modules",
    "Monomorphic",
    "Morphism",
    "Namespace",
    "Next",
    "No",
    "NoInline",
    "NonCumulative",
    "Notation",
    "Number",
    "OCaml",
    "Obligation",
    "Obligations",
    "Off",
    "On",
    "Opaque",
    "Open",
    "Optimize",
    "Options",
    "Parameter",
    "Parameters",
    "Parametric",
    "Path",
    "Paths",
    "Polymorphic",
    "Prenex",
    "Preterm",
    "Primitive",
    "Print",
    "Private",
    "Profile",
    "Program",
    "Projections",
    "Proof",
    "Prop",
    "PropBinOp",
    "PropOp",
    "PropUOp",
    "Property",
    "Proposition",
    "Pwd",
    "Qed",
    "Quit",
    "Rec",
    "Record",
    "Recursive",
    "Redirect",
    "Reduction",
    "Register",
    "Registered",
    "Relation",
    "Remark",
    "Remove",
    "Require",
    "Reserved",
    "Reset",
    "Resolve",
    "Restart",
    "Rewrite",
    "Right",
    "Ring",
    "Rings",
    "SProp",
    "Saturate",
    "Save",
    "Scheme",
    "Scope",
    "Scopes",
    "Search",
    "SearchPattern",
    "SearchRewrite",
    "Section",
    "Separate",
    "Set",
    "Setoid",
    "Show",
    "Signatures",
    "Solve",
    "Solver",
    "Sort",
    "Sortclass",
    "Sorted",
    "Step",
    "Strategies",
    "Strategy",
    "String",
    "Structure",
    "SubClass",
    "Subgraph",
    "Succeed",
    "SuchThat",
    "Table",
    "Tables",
    "Tactic",
    "Term",
    "Test",
    "TestCompile",
    "Theorem",
    "Time",
    "Timeout",
    "To",
    "Transparent",
    "Type",
    "TypeClasses",
    "Typeclasses",
    "Types",
    "Typing",
    "UnOp",
    "UnOpSpec",
    "Undelimit",
    "Undo",
    "Unfocus",
    "Unfocused",
    "Unfold",
    "Universe",
    "Universes",
    "Unset",
    "Unshelve",
    "Variable",
    "Variables",
    "Variant",
    "Verbose",
    "View",
    "Visibility",
    "Zify",
    "_",
    "abstract",
    "absurd",
    "admit",
    "after",
    "all",
    "and",
    "any",
    "apply",
    "as",
    "assert",
    "assert_succeeds",
    "associativity",
    "assumption",
    "at",
    "auto",
    "autoapply",
    "autorewrite",
    "autounfold",
    "autounfold_one",
    "before",
    "best_effort",
    "beta",
    "bfs",
    "bidirectionality",
    "bigint",
    "binder",
    "bottom",
    "bottomup",
    "btauto",
    "by",
    "case",
    "casetype",
    "cbn",
    "cbv",
    "change",
    "change_no_check",
    "choice",
    "clear",
    "clearbody",
    "closed",
    "cofix",
    "compare",
    "completeness",
    "compute",
    "concl",
    "congr",
    "congruence",
    "constants",
    "constr",
    "constr_eq",
    "constr_eq_nounivs",
    "constr_eq_strict",
    "constructor",
    "context",
    "contradiction",
    "custom",
    "cut",
    "cutoff",
    "cutrewrite",
    "cycle",
    "debug",
    "decidable",
    "decide",
    "decompose",
    "default",
    "delta",
    "dependent",
    "destauto",
    "destruct",
    "dfs",
    "discriminate",
    "discriminated",
    "div",
    "do",
    "eapply",
    "eassert",
    "eassumption",
    "eauto",
    "ecase",
    "econstructor",
    "edestruct",
    "ediscriminate",
    "eelim",
    "eenough",
    "eexact",
    "eexists",
    "einduction",
    "einjection",
    "eintros",
    "eleft",
    "elim",
    "elimtype",
    "else",
    "emp",
    "end",
    "enough",
    "epose",
    "eps",
    "eqn",
    "equality",
    "eremember",
    "erewrite",
    "eright",
    "eset",
    "esimplify_eq",
    "esplit",
    "etransitivity",
    "eval",
    "evar",
    "exact",
    "exact_no_check",
    "exactly_once",
    "exists",
    "expand",
    "external",
    "extra",
    "f_equal",
    "fail",
    "field_lookup",
    "finish_timing",
    "first",
    "firstorder",
    "fix",
    "fold",
    "for",
    "forall",
    "format",
    "fresh",
    "from",
    "fun",
    "functional",
    "gen",
    "generalize",
    "generalize_eqs",
    "generalize_eqs_vars",
    "generally",
    "gfail",
    "gintuition",
    "give_up",
    "global",
    "goal",
    "graph",
    "guard",
    "has_evar",
    "have",
    "head",
    "head_of_constr",
    "headconcl",
    "headhyp",
    "hget_evar",
    "hint",
    "hints",
    "hnf",
    "hresolve_core",
    "hyp",
    "id",
    "ident",
    "idtac",
    "if",
    "implicits",
    "in",
    "induction",
    "infoH",
    "info_auto",
    "info_eauto",
    "info_trivial",
    "injection",
    "inline",
    "innermost",
    "inside",
    "instantiate",
    "into",
    "intro",
    "intros",
    "inversion",
    "inversion_clear",
    "iota",
    "is",
    "is_cofix",
    "is_const",
    "is_constructor",
    "is_evar",
    "is_fix",
    "is_ground",
    "is_ind",
    "is_proj",
    "is_var",
    "isn't",
    "lapply",
    "last",
    "lazy",
    "lazymatch",
    "left",
    "let",
    "level",
    "loss",
    "ltac",
    "ltac1",
    "ltac1val",
    "mapping",
    "match",
    "max",
    "measure",
    "morphism",
    "move",
    "multimatch",
    "mutable",
    "name",
    "native_cast_no_check",
    "native_compute",
    "never",
    "next",
    "no",
    "nomatch",
    "not_evar",
    "notypeclasses",
    "nsatz_compute",
    "numgoals",
    "of",
    "old_hints",
    "once",
    "only",
    "opaque",
    "open_constr",
    "optimize_heap",
    "outermost",
    "outside",
    "par",
    "parsing",
    "pat",
    "pattern",
    "pose",
    "postprocess",
    "power",
    "power_tac",
    "preprocess",
    "printing",
    "profile",
    "profiling",
    "progress",
    "progress_evars",
    "proof",
    "protect_fv",
    "proved",
    "rec",
    "record",
    "red",
    "reference",
    "refine",
    "refl",
    "reflexivity",
    "remember",
    "removed",
    "rename",
    "repeat",
    "replace",
    "reset",
    "restart_timer",
    "return",
    "reverse",
    "revert",
    "revgoals",
    "rewrite",
    "rewrite_db",
    "rewrite_strat",
    "right",
    "ring_lookup",
    "rtauto",
    "scope",
    "scopes",
    "set",
    "setoid",
    "setoid_etransitivity",
    "setoid_reflexivity",
    "setoid_rewrite",
    "setoid_symmetry",
    "setoid_transitivity",
    "shelve",
    "shelve_unifiable",
    "show",
    "sign",
    "signature",
    "simpl",
    "simple",
    "simplify_eq",
    "soft",
    "solve",
    "solve_constraints",
    "specialize",
    "specialize_eqs",
    "split",
    "ssrinstancesofruleL2R",
    "ssrinstancesofruleR2L",
    "ssrinstancesoftpat",
    "start",
    "stepl",
    "stepr",
    "stop",
    "strict",
    "struct",
    "subst",
    "substitute",
    "subterm",
    "subterms",
    "suff",
    "suffices",
    "sum",
    "swap",
    "symmetry",
    "terms",
    "then",
    "time",
    "timeout",
    "top",
    "topdown",
    "transitivity",
    "transparent",
    "transparent_abstract",
    "trivial",
    "try",
    "tryif",
    "type",
    "type_term",
    "typeclasses",
    "under",
    "unfold",
    "unify",
    "unlock",
    "unshelve",
    "until",
    "using",
    "value",
    "via",
    "vm_cast_no_check",
    "vm_compute",
    "warning",
    "wf",
    "where",
    "with",
    "with_strategy",
    "without",
    "wlia",
    "wlog",
    "wlra_Q",
    "wnia",
    "wnra_Q",
    "wpsatz_Q",
    "wpsatz_Z",
    "wsos_Q",
    "wsos_Z",
    "xlia",
    "xlra_Q",
    "xlra_R",
    "xnia",
    "xnra_Q",
    "xnra_R",
    "xpsatz_Q",
    "xpsatz_R",
    "xpsatz_Z",
    "xsos_Q",
    "xsos_R",
    "xsos_Z",
    "zeta",
    "zify_elim_let",
    "zify_iter_let",
    "zify_iter_specs",
    "zify_op",
    "zify_saturate",
]
